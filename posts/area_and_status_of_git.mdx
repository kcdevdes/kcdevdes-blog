---
title: 깃의 영역 분리 및 상태가 무엇인가?
date: 2023-04-19
description: 깃의 개념적인 부분을 살펴본다. 깃의 영역 분리와 각 영역이 어떠한 역할을 하는지, 그리고 파일들은 어떤 상태를 가지는지 알아본다.
category: git
---

# 👶🏻 이번에 알아볼 내용은?

---

지난번 글에서는 깃을 init, add, commit을 해보면서 내부 폴더 .git에 어떠한 변화가 생기는지 알아보았다.<br />
이번에 알아볼 것은 실제 폴더를 살피는 것이 아닌 **개념적인 내용**을 알아볼 계획이다.<br />
깃이 **나누어둔 영역**들과 **파일의 상태**라는 개념 한 번 알아보면서 우리가 지난 시간에 했던 add, commit이 무엇을 하는 명령어인지 알아본다.

<br />

# 🏠 깃의 영역 분리

---

![](https://velog.velcdn.com/images/yooji0415/post/74252d0b-01bf-41d5-99a1-2975d2345a6f/image.svg)

이미지 출처: [https://support.nesi.org.nz/hc/en-gb/articles/360001508515-Git-Reference-Sheet](https://support.nesi.org.nz/hc/en-gb/articles/360001508515-Git-Reference-Sheet)

우선적으로 위 그림에 대한 이해가 필요하다.

깃은 저장 공간을 **논리적으로 분리**한다.

깃은 크게 **작업을 하는 공간(Working), 임시로 저장하는 공간(stage), 실제로 기록하는 공간(repository)** 으로 나눈다. 이렇게 공간을 나누면서 깃의 동작과 이력을 효율적으로 처리할 수 있다.

## 워킹 디렉터리(Working Directory)

**작업을 하는 공간을 의미**한다.
말 그대로 **로컬 저장소에 접근**할 수 있으며, **실제로 파일을 생성하고 수정**하는 공간이다.

## 스테이지(Staging Area)

워킹 디렉터리와 레포지토리 사이에 있는 **임시 영역**이다. <br />
깃은 워킹 티렉터리에서 작업이 끝난 파일을 스테이지로 잠시 복사한다. 이때 복사한다는 의미는 콘텐츠 내용을 직접 가지고 있는 것이 아닌 단지 **파일의 추적 상태 정보들만 기록**한다.

이렇게 임시 영역인 스테이지를 별도로 운영하는 것은 **커밋을 빠르게 처리하기 위함**이다.

## 레포지토리(Repository)

**스테이지 영역에서 기리키는 파일 내용을 기반으로 변경된 차이점을 기록**한다.

<br />

# 📁 파일의 상태

---

![](https://velog.velcdn.com/images/yooji0415/post/00d06629-1bc5-439d-9ee5-f1351e207a0f/image.png)

이미지 출처: [https://git-scm.com/book/ko/v2/Git의-기초-수정하고-저장소에-저장하기](https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B3%A0-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0)

깃이 논리적으로 파일을 관리하기 위해서 영역 분리를 한다고 했다.

이 영역에 따라서 우리는 **파일의 상태를 나눈다**. 위 그림을 보면 4가지 정도인 것으로 보이는데 한 번 알아보자.

## Untracked / Tracked

깃은 **추적 개념**이란 것을 가지고 있다. <br />
깃은 지정된 파일들의 모든 것을 추적하는 관리 시스템이다. 깃은 워킹 디렉터리에 있는 파일들을 **추척됨(Tracked)** 과 **추적되지 않음(Untracked)** 로 나눈다.

**실제 작업 중인 파일은 워킹 디렉터리 안**에 있다. <br />
워킹 디렉터리는 현재 작업 중인 소스 코드를 담고 있으며, 운영 체제도 워킹 디렉터리 안에 있는 파일들만 접근하고 수정할 수 있다. 워킹 디렉터리는 사용자 작업 공간이라 생각하면 된다.

_이 공간에 파일을 추가하거나 수정했다고 해서 깃이 자동으로 파일을 관리해주지 않는다._

워킹 디렉터리에서 **새로 생성된 파일들은 모두 Untracked 상태**이다. 이 파일을 관리하려면 깃에게 ‘추적해줘’ 하고 통지해야 한다.

그렇다면 어떻게 추적해달라고 요청하고 이를 **Tracked 상태로 바꿀 수** 있을까?<br />
이때가 바로 우리가 사용했던 **git add 명령어를 사용**하는 시점이다.

깃이라고 모든 파일을 완벽하게 처리할 수는 없다. 수많은 파일을 자동으로 처리한다고 하면 시스템에 부하가 올 것이기 때문이다. 이러한 요인 때문에 깃은 **요청받은 파일들만 추적 관리하는 것**이다.

## Stage / Unstage

워킹 디렉터리에 있는 tracked 상태의 파일들은 스테이지 영역과 긴밀한 관계를 맺는다.<br />
**스테이지 영역으로 등록된 모든 파일은 Untracked 상태에서 Tracked 상태로 변경**된다.<br />
스테이지는 워킹 디렉터리 안에 있는 파일들의 추적 상태를 관리하는 역할을 수행한다.

이 스테이지 영역 안에서도 크게 두 상태로 구분한다. 바로 **Stage 상태와 Unstage 상태**이다.<br />
**깃이 변화 이력을 기록하려면 파일들의 최종 상태가 Stage 상태**여야 한다. **Unstage 상태라면 파일에 변화가 있다는 것**을 의미한다.

즉 **스테이지 영역에 있는 파일과 워킹 디렉터리 안에 있는 파일 내용에 차이가 있을 때는 Unstage 상태가 된다는 것**이다. Unstage 상태라고 해서 실제 파일이 없어지는 것은 아니다. 단지 파일이 수정되어 **임시적으로 스테이지 목록에서 제외**된 것이다. 이 때 다시 **git add를 통해서 스테이지에 추가**할 수 있다.

## Modified / Unmodified

코드를 변경하는 것은 워킹 디렉터리에서 파일을 수정하는 것을 의미한다.<br />
파일이 수정되면 워킹 디렉터리와 스테이지 간 내용이 일치하지 않게 된다. 따라서 **스테이지는 수정한 파일과 원본 파일로 구분하려고 Modified 상태와 Unmodified 상태로 표현**한다.

- **Modified 상태**: tracked 상태의 파일이 수정되면 스테이지는 파일 상태를 Modified로 변경한다. 그러면 수정된 파일은 잠시 스테이지에서 제외된다. 이를 다시 스테이지로 올리려면 git add를 해주어야 한다.<br />
- **Unmodified 상태**: tracked 상태이면서 스테이지에서 한 번도 수정하지 않은 원본 상태를 의미한다. 이렇게 수정되지 않은 파일들은 재등록 하지 않아도 된다.

![](https://velog.velcdn.com/images/yooji0415/post/a8fdfa0f-f09f-4bc6-979c-592b33fabfb9/image.png)

위 내용들을 바탕으로 그림을 그리면 위와 같은 그림이 된다.

한 번 간단하게 정리하면 아래와 같다.

- **워킹 디렉터리에서 등록 명령어 git add를 실행하면 스테이지에 등록**된다. 이 때 자동으로 **Tracked 상태**가 된다.
- 파일을 **수정하지 않으면 계속 Stage 영역**에서 머문다.
- 파일이 **수정되면 Modified 상태**가 되고, 스테이지에서 떨어져 나와 **Unstage 상태**가 된다.
- Unstage 상태의 파일은 워킹 디렉터리에 잠시 담아둔다. 이때 다시 **git add를 통해서 stage 상태로 변경**할 수 있다.

스테이지라는 말이 영역을 표현할 때도 사용되고 파일의 상태를 말할 때도 사용되니 이점이 약간 혼동될 수 있다.<br />
(실제로 학습을 하고 정리도 하면서 용어가 좀 혼동되는 경향이 있었다…)

<br />

# 🤨 다음에 학습해볼 내용

---

원래는 영역 분리와 파일의 상태에 관해서 학습하고 commit의 동작 흐름과 변화도 적으려 했으나 둘을 모두 적으면 글이 터질 것 같다… 따라서 다음 글은 commit 동작 흐름을 한 번 살펴보면서 실제 코드나 파일상의 변화를 확인해볼 예정이다.
